{
    "client_name": "HaloDAO",
    "commit_hash": "7fab901ff5aa136972ce2533f39f8d912e5e363c",
    "date": "August 2021",
    "date_interval": "16th of August to 27th of August, 2021",
    "issues": [
        {
            "active_lock_reason": null,
            "assignee": null,
            "assignees": [],
            "author_association": "CONTRIBUTOR",
            "body": "**Description**\r\n\r\nWhen a user wants to cross the bridge, they can `deposit` some tokens into the contract by calling `PrimaryBridge.deposit()`.\r\n\r\nhttps://github.com/monoceros-alpha/review-halo-token-bridge-2021-08/blob/96ddd26aa73190d71b2b7413c008e6516b8fd29b/code/contracts/PrimaryBridge.sol#L21-L29\r\n\r\nIn this case, their tokens are locked in the bridge, some accounting is done, and an event is emitted.\r\n\r\nhttps://github.com/monoceros-alpha/review-halo-token-bridge-2021-08/blob/96ddd26aa73190d71b2b7413c008e6516b8fd29b/code/contracts/PrimaryBridge.sol#L27\r\n\r\nIf the same user calls the `deposit` method twice, with the same value, in the same block, 2 identical events will be emitted by the contract.\r\n\r\nEach event will have the same:\r\n\r\n- `amount`\r\n- `chainId`\r\n- `block.timestamp`\r\n- `msg.sender`\r\n\r\nThe service watching the contract for events can't differentiate between these 2 deposits. The service also needs to call `SecondaryBridge.mint()` on the destination `chainId`.\r\n\r\nTo better track each `deposit` and paired `mint`, a `nonce` can be generated by the `PrimaryBridge` to make sure the same `deposit` was executed once and only once. \r\n\r\nHaving a `nonce` will help track each individual `deposit` and make sure that each `deposit` was executed on the destination chain.\r\n\r\nThe contract needs to keep track of the nonces and can respond with `true` or `false` (and possibly other info) to make sure the same bridge cross was executed on the destination chain.\r\n\r\nThis reduces the responsibility of the relayer because tracking each deposit that happens in the contract, which provides more security, helps with duplicate prevention as well as having a confirmation available on-chain for each deposit.\r\n\r\nConsider this highly simplified example.\r\n\r\nA user wants to cross the bridge; thus, they need to call the `PrimaryBridge.deposit()` below.\r\n\r\n```solidity\r\nimport {IERC20} from './IERC20.sol';\r\n\r\ncontract PrimaryBridge {\r\n    event DepositReceived(\r\n        uint256 nonce,\r\n        uint256 amount, \r\n        uint256 chainId, \r\n        uint256 timestamp, \r\n        address indexed from\r\n    );\r\n    \r\n    address internal _token;\r\n    uint public nextNonce;\r\n    \r\n    function deposit(uint amount, uint chainId) external {\r\n        IERC20(_token).transferFrom(msg.sender, address(this), amount); \r\n        \r\n        // Get the current nonce\r\n        uint currentNonce = nextNonce;\r\n        \r\n        // Increment the next nonce\r\n        nextNonce += 1;\r\n        \r\n        // Emit an event containing the current nonce.\r\n        //\r\n        // This `nonce` needs to be sent by the relayer to the `SecondaryBridge.mint()` method\r\n        // to correctly an uniquely track each deposit.\r\n        emit DepositReceived(\r\n            currentNonce,\r\n            amount, \r\n            chainId, \r\n            block.timestamp, \r\n            msg.sender\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nOnce the method was executed successfully, an event is emitted containing the currently implemented values, as well as a generated unique nonce. This unique nonce is then used by the relayer. Also, this nonce can be useful for the user to track and prove their transaction was not mined (in case the relayer is faulty).\r\n\r\nThe relayer picks up the event and has to call `SecondaryBridge.mint()` to create the user's tokens on the destination chain.\r\n\r\n```solidity\r\nimport {IERC20} from './IERC20.sol';\r\n\r\ncontract Secondary {\r\n    event Minted(\r\n        uint nonce,\r\n        uint amount,\r\n        uint timestamp,\r\n        address indexed to,\r\n        uint chainId\r\n    );\r\n\r\n    uint256 private _chainId;\r\n    address internal _token;\r\n    mapping(uint => bool) public nonces;\r\n\r\n    function mint(\r\n        // This nonce is sent by the relayer\r\n        // it's the one the method `PrimaryBridge.deposit()` emitted\r\n        uint nonce,\r\n        address account,\r\n        uint amount\r\n    ) external returns (bool) {\r\n        // Make sure this nonce was not used before\r\n        require(nonces[nonce] == false, \"Deposit already processed\");\r\n\r\n        // Mark this nonce as used\r\n        nonces[nonce] = true;\r\n\r\n        // Create the tokens\r\n        IERC20(_token).mint(account, amount);\r\n\r\n        // Emit an event containing this nonce along with all the other details\r\n        emit Minted(nonce, amount, block.timestamp, account, _chainId);\r\n\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\nThis time the `mint` method has an additional argument: `nonce`. Which uniquely identifies the user's deposit. The relayer has to provide this argument to make sure the deposit is uniquely tracked. \r\n\r\nBecause of this check, each deposit is executed only once, even if the relayer software has a bug and calls the `mint` method multiple times.\r\n\r\n```solidity\r\n        // Make sure this nonce was not used before\r\n        require(nonces[nonce] == false, \"Deposit already processed\");\r\n```\r\n\r\nIf the relayer misbehaves and does not process all deposits, checking if a nonce was processed simplifies providing support for the affected user. This is possible because a public nonce mapping is available in the contract.\r\n\r\n```solidity\r\n    mapping(uint => bool) public nonces;\r\n```\r\n\r\nThis can be cross-checked with the events emitted by the `PrimaryBridge`; thus, if a nonce was not processed, the event emitting that nonce has all of the necessary details to solve the users' issue.\r\n\r\nA few additional things need to be considered:\r\n\r\n- You might want to generate individual nonces for each chain. Because there is a `PrimaryBridge`, you could have multiple `SecondaryBridges`; thus, it might help you to track each chain separately. Each chain can have its own list of nonces.\r\n- Moving from `PrimaryBridge` to `SecondaryBridge` was discussed above, but also the inverse operation also needs to be tracked. Make sure you similarly track `SecondaryBridge.burn` to `PrimaryBridge.release`.\r\n- This is extremely simplified. The code is super slim; make sure not to copy-paste. It's just a proof of concept.\r\n- Depending on the amount of complexity you want to add, a structure describing each deposit / burn can be saved in the contract. If you want to later provide or check the actions on-chain, the contract needs to have information about the deposits and the burns. The events are not visible to any of the contracts on-chain. They only serve off-chain services.\r\n- Crossing the bridge heavily relies on the relayer running correctly. An upgrade of your system can provide a mechanism for the user to trigger mint / release themselves if they provide correct cryptographic proof. This, however, will add significant complexity.\r\n\r\n**Recommendation**\r\n\r\nConsider adding a unique tracking mechanism similar to the `nonce` example above to reduce the responsibility of the relayer software, help track successful / un-executed deposits easier and move some of the reliability concerns on-chain.\r\n\r\n",
            "closed_at": "2021-08-27T09:54:52Z",
            "comments": 4,
            "comments_url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08/issues/1/comments",
            "created_at": "2021-08-24T12:30:52Z",
            "events_url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08/issues/1/events",
            "html_url": "https://github.com/monoceros-alpha/review-halo-token-bridge-2021-08/issues/1",
            "id": 978047135,
            "labels": [
                {
                    "color": "667788",
                    "default": false,
                    "description": null,
                    "id": 3273498976,
                    "name": "Report",
                    "node_id": "MDU6TGFiZWwzMjczNDk4OTc2",
                    "url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08/labels/Report"
                },
                {
                    "color": "34C759",
                    "default": false,
                    "description": null,
                    "id": 3273499002,
                    "name": "Informational",
                    "node_id": "MDU6TGFiZWwzMjczNDk5MDAy",
                    "url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08/labels/Informational"
                }
            ],
            "labels_url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08/issues/1/labels{/name}",
            "locked": false,
            "milestone": null,
            "node_id": "MDU6SXNzdWU5NzgwNDcxMzU=",
            "number": 1,
            "performed_via_github_app": null,
            "repository_url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08",
            "state": "closed",
            "title": "Consider adding a nonce to track each deposit / burn operation",
            "updated_at": "2021-08-27T09:54:52Z",
            "url": "https://api.github.com/repos/monoceros-alpha/review-halo-token-bridge-2021-08/issues/1",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/547012?v=4",
                "events_url": "https://api.github.com/users/cleanunicorn/events{/privacy}",
                "followers_url": "https://api.github.com/users/cleanunicorn/followers",
                "following_url": "https://api.github.com/users/cleanunicorn/following{/other_user}",
                "gists_url": "https://api.github.com/users/cleanunicorn/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/cleanunicorn",
                "id": 547012,
                "login": "cleanunicorn",
                "node_id": "MDQ6VXNlcjU0NzAxMg==",
                "organizations_url": "https://api.github.com/users/cleanunicorn/orgs",
                "received_events_url": "https://api.github.com/users/cleanunicorn/received_events",
                "repos_url": "https://api.github.com/users/cleanunicorn/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/cleanunicorn/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/cleanunicorn/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/cleanunicorn"
            }
        }
    ],
    "person_days": "20",
    "project_name": "HALO Token Bridge",
    "review_period": "2 weeks",
    "source_repository": "git@github.com:HaloDAO/token-bridge.git",
    "template": "./Readme.md.mustache"
}